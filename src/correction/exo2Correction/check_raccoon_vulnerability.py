#!/usr/bin/env python3
"""
V√âRIFICATEUR DE VULN√âRABILIT√â RACCOON
====================================

Script pour v√©rifier si un serveur TLS est vuln√©rable √† l'attaque Raccoon.

Usage:
    python3 check_raccoon_vulnerability.py <host> <port>
    python3 check_raccoon_vulnerability.py localhost 8443
"""

import ssl
import socket
import sys
import time
import subprocess
import shlex
import re
import os
from typing import Tuple, Optional, List, Dict
from enum import Enum

class VulnerabilityLevel(Enum):
    VULNERABLE = "üö® VULN√âRABLE"
    PROTECTED = "üõ°Ô∏è  PROT√âG√â"
    NOT_VULNERABLE = "‚úÖ NON VULN√âRABLE"
    UNKNOWN = "‚ùì INCONNU"

class RaccoonChecker:
    """V√©rificateur de vuln√©rabilit√© Raccoon"""
    
    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port
        self.results = {}
    
    def check_vulnerability(self) -> Dict:
        """Effectue toutes les v√©rifications de vuln√©rabilit√©"""
        print(f"üîç Analyse de la vuln√©rabilit√© Raccoon pour {self.host}:{self.port}")
        print("=" * 60)
        
        
        # 1. V√©rifier la connectivit√©
        if not self._check_connectivity():
            return {"status": VulnerabilityLevel.UNKNOWN, "reason": "Impossible de se connecter"}
        
        env_tls_version = os.environ.get('TLS_VERSION', '')
        if env_tls_version == '1.3':
            print(f"üåç Configuration globale d√©tect√©e: TLS_VERSION={env_tls_version}")
            return {
                "status": VulnerabilityLevel.NOT_VULNERABLE,
                "reason": "Configuration TLS 1.3 d√©tect√©e - non vuln√©rable √† Raccoon",
                "tls_info": {"version": "TLSv1.3 (configur√©)", "cipher_name": "Configuration TLS 1.3"},
                "recommendations": [
                    "‚úÖ TLS 1.3 configur√© (d√©tection globale)",
                    "‚úÖ TLS 1.3 utilise toujours des cl√©s √©ph√©m√®res",
                    "üîí Non vuln√©rable √† l'attaque Raccoon"
                ]
            }
        
        # 2. Analyser la configuration TLS
        tls_info = self._analyze_tls_configuration()
        if not tls_info:
            return {"status": VulnerabilityLevel.UNKNOWN, "reason": "Impossible d'analyser la configuration TLS"}
        
        # 3. √âvaluer la vuln√©rabilit√©
        vulnerability_status = self._evaluate_vulnerability(tls_info)
        
        return {
            "status": vulnerability_status["level"],
            "reason": vulnerability_status["reason"],
            "tls_info": tls_info,
            "recommendations": vulnerability_status["recommendations"]
        }
    
    def _check_connectivity(self) -> bool:
        """V√©rifie la connectivit√© au serveur"""
        try:
            print(f"üì° Test de connectivit√©...")
            sock = socket.create_connection((self.host, self.port), timeout=10)
            sock.close()
            print(f"‚úì Connexion √©tablie avec {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"‚ùå Impossible de se connecter: {e}")
            return False
    
    def _analyze_tls_configuration(self) -> Optional[Dict]:
        """Analyse la configuration TLS du serveur"""
        try:
            print(f"\nüîê Analyse de la configuration TLS...")
            
            # Cr√©er un contexte TLS permissif pour l'analyse
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            # Permettre les anciens protocoles et ciphers pour l'analyse
            context.set_ciphers('ALL:@SECLEVEL=0')
            
            with socket.create_connection((self.host, self.port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=self.host) as ssock:
                    # R√©cup√©rer les informations de la connexion
                    tls_info = {
                        "version": ssock.version(),
                        "cipher": ssock.cipher(),
                        "cert": ssock.getpeercert(binary_form=False),
                        "cert_der": ssock.getpeercert(binary_form=True)
                    }
                    
                    print(f"‚úì Version TLS: {tls_info['version']}")
                    if tls_info['cipher']:
                        cipher_name, tls_version, secret_bits = tls_info['cipher']
                        print(f"‚úì Suite de chiffrement: {cipher_name}")
                        print(f"‚úì Bits secrets: {secret_bits}")
                        tls_info['cipher_name'] = cipher_name
                        tls_info['secret_bits'] = secret_bits
                    
                    return tls_info
                    
        except Exception as e:
            print(f"‚ùå Erreur lors de l'analyse TLS: {e}")
            return None
    
    def _evaluate_vulnerability(self, tls_info: Dict) -> Dict:
        """√âvalue le niveau de vuln√©rabilit√© bas√© sur la configuration TLS"""
        print(f"\nüéØ √âvaluation de la vuln√©rabilit√© Raccoon...")
        
        version = tls_info.get("version", "")
        cipher_name = tls_info.get("cipher_name", "")
        
        # Crit√®re 1: Version TLS
        if "TLSv1.3" in version:
            return {
                "level": VulnerabilityLevel.NOT_VULNERABLE,
                "reason": "TLS 1.3 n'est pas vuln√©rable √† Raccoon (utilise toujours des cl√©s √©ph√©m√®res)",
                "recommendations": [
                    "‚úÖ Le serveur utilise TLS 1.3",
                    "‚úÖ Les cl√©s sont toujours √©ph√©m√®res en TLS 1.3",
                    "üîí Configuration s√©curis√©e contre Raccoon"
                ]
            }

        if "TLSv1.2" in version:
            print("‚ö†Ô∏è  Version TLS 1.2 d√©tect√©e - TLS 1.2 peut √™tre vuln√©rable selon la configuration")
        
        if "TLSv1.2" not in version:
            return {
                "level": VulnerabilityLevel.UNKNOWN,
                "reason": f"Version TLS non support√©e ou ancienne: {version}",
                "recommendations": [
                    "‚ö†Ô∏è  Mettre √† jour vers TLS 1.2 minimum",
                    "üîÑ Id√©alement migrer vers TLS 1.3"
                ]
            }
        
        # Crit√®re 2: Algorithme d'√©change de cl√©s
        is_dhe = self._is_dhe_cipher(cipher_name)
        is_rsa = self._is_rsa_cipher(cipher_name)
        is_ecdhe = self._is_ecdhe_cipher(cipher_name)
        
        print(f"üìã Analyse du cipher: {cipher_name}")
        print(f"   DHE d√©tect√©: {is_dhe}")
        print(f"   RSA d√©tect√©: {is_rsa}")
        print(f"   ECDHE d√©tect√©: {is_ecdhe}")
        
        if is_rsa:
            return {
                "level": VulnerabilityLevel.NOT_VULNERABLE,
                "reason": "Utilise RSA (pas de Diffie-Hellman) - non vuln√©rable √† Raccoon",
                "recommendations": [
                    "‚úÖ RSA n'est pas vuln√©rable √† Raccoon",
                    "üí° Consid√©rer ECDHE pour Perfect Forward Secrecy",
                    "üîÑ Migrer vers TLS 1.3 pour une s√©curit√© optimale"
                ]
            }
        
        if is_ecdhe:
            # ECDHE moderne avec cl√©s toujours √©ph√©m√®res
            return {
                "level": VulnerabilityLevel.PROTECTED,
                "reason": "Utilise ECDHE avec cl√©s √©ph√©m√®res - prot√©g√© contre Raccoon",
                "recommendations": [
                    "‚úÖ ECDHE utilise des cl√©s √©ph√©m√®res",
                    "‚úÖ Impl√©mentation moderne r√©sistante √† Raccoon",
                    "üîÑ Consid√©rer la migration vers TLS 1.3"
                ]
            }
        
        if is_dhe:
            # DHE potentiellement vuln√©rable - v√©rifier la r√©utilisation des cl√©s
            print(f"üîç V√©rification de la r√©utilisation des cl√©s DH...")
            key_reuse_analysis = self._check_dh_key_reuse()
            
            recommendations = [
                "‚ö†Ô∏è  DHE d√©tect√© - potentiellement vuln√©rable",
                "üîß V√©rifier que les cl√©s DH sont vraiment √©ph√©m√®res",
            ]
            
            if key_reuse_analysis["reused"]:
                return {
                    "level": VulnerabilityLevel.VULNERABLE,
                    "reason": f"DHE avec r√©utilisation de cl√©s d√©tect√©e - {key_reuse_analysis['details']}",
                    "recommendations": recommendations + [
                        "üö® URGENT: Cl√©s DH r√©utilis√©es d√©tect√©es",
                        "üîß Configurer des cl√©s vraiment √©ph√©m√®res",
                        "üîß Chaque connexion doit utiliser une nouvelle cl√© DH"
                    ]
                }
            else:
                return {
                    "level": VulnerabilityLevel.PROTECTED,
                    "reason": "DHE avec cl√©s √©ph√©m√®res - prot√©g√© contre Raccoon",
                    "recommendations": recommendations
                }
        
        
        # Cas non identifi√©
        return {
            "level": VulnerabilityLevel.UNKNOWN,
            "reason": f"Configuration {cipher_name}",
            "recommendations": [
                "‚ùì Configuration TLS non standard",
                "üîç Analyse manuelle recommand√©e",
                "üîÑ Consid√©rer la mise √† jour vers TLS 1.3"
            ]
        }
    
    def _run_openssl_capture_ske(self) -> Optional[bytes]:
        """Ex√©cute openssl s_client -msg et renvoie le bloc ServerKeyExchange brut (bytes) si d√©tect√©.
        N√©cessite que 'openssl' soit install√© dans l'environnement d'ex√©cution.
        """
        cmd = [
            "openssl", "s_client",
            "-connect", f"{self.host}:{self.port}",
            "-tls1_2",
            "-servername", self.host,
            "-cipher", "DHE-RSA-AES256-GCM-SHA384:@SECLEVEL=0",
            "-msg",
            "-ign_eof",
        ]
        try:
            # openssl -msg √©crit la trace sur stderr
            proc = subprocess.run(
                cmd,
                input=b"\n\n",  # envoie EOF rapidement
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=10
            )
            combined = (proc.stdout or b"") + b"\n" + (proc.stderr or b"")
            text = combined.decode(errors='ignore')
            # D√©limiter le bloc ServerKeyExchange
            # Rechercher un en-t√™te indicatif et capturer le dump hex qui suit
            # OpenSSL imprime souvent des sections commen√ßant par "ServerKeyExchange" ou "server key exchange"
            ske_re = re.compile(r"Server\s*Key\s*Exchange.*?\n(.*?)\n\S", re.IGNORECASE | re.DOTALL)
            m = ske_re.search(text)
            if not m:
                # Tentative alternative: capturer entre lignes marqu√©es "Handshake .* ServerKeyExchange" et la prochaine "Handshake"
                ske_re_alt = re.compile(r"Handshake.*ServerKeyExchange.*?\n(.*?)\n(?:Handshake|ssl3|TLS|>>>|<<<)", re.IGNORECASE | re.DOTALL)
                m = ske_re_alt.search(text)
            if not m:
                # Alternative basique: capturer le premier bloc hex cons√©cutif de 3+ lignes apr√®s mention de "Server"
                approx = re.compile(r"Server.*?\n((?:\s*[0-9a-fA-F]{2}(?:\s+[0-9a-fA-F]{2})+\s*\n){3,})", re.IGNORECASE)
                m = approx.search(text)
            if not m:
                return None
            hex_block = m.group(1)
            # Extraire les octets hex √† partir de lignes style "0000 - aa bb cc ..."
            bytes_list = []
            for line in hex_block.splitlines():
                line = line.strip()
                # Exemples de formats possibles
                # 0000 - aa bb cc dd ee ff
                #        aa bb cc dd
                parts = re.findall(r"\b[0-9a-fA-F]{2}\b", line)
                for p in parts:
                    bytes_list.append(int(p, 16))
            if not bytes_list:
                return None
            return bytes(bytes_list)
        except Exception:
            return None

    def _extract_dh_pub_from_ske(self, ske_bytes: bytes) -> Optional[bytes]:
        """Parse la structure ServerKeyExchange (DHE) pour extraire Y_s.
        Format: dh_p (2 octets longueur) | p | dh_g (2) | g | dh_Ys (2) | Ys | Signature...
        """
        try:
            i = 0
            if len(ske_bytes) < 6:
                return None
            # p
            Lp = (ske_bytes[i] << 8) | ske_bytes[i+1]; i += 2
            if i + Lp > len(ske_bytes):
                return None
            i += Lp
            # g
            if i + 2 > len(ske_bytes):
                return None
            Lg = (ske_bytes[i] << 8) | ske_bytes[i+1]; i += 2
            if i + Lg > len(ske_bytes):
                return None
            i += Lg
            # Ys
            if i + 2 > len(ske_bytes):
                return None
            Ly = (ske_bytes[i] << 8) | ske_bytes[i+1]; i += 2
            if i + Ly > len(ske_bytes):
                return None
            Ys = ske_bytes[i:i+Ly]
            return Ys
        except Exception:
            return None

    def _check_dh_key_reuse(self) -> Dict:
        """V√©rifie si les cl√©s DH sont r√©utilis√©es en extraisant la cl√© publique DH (Y_s) via openssl s_client -msg."""
        print(f"üîë Test de r√©utilisation des cl√©s DH (extraction Y_s via openssl ou header X-DH-Pub)...")

        # 1) Tentative simple: lire l'en-t√™te HTTP X-DH-Pub expos√© par le serveur (si pr√©sent)
        def fetch_dh_pub_header() -> Optional[str]:
            try:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                ctx.set_ciphers('DHE-RSA-AES256-GCM-SHA384:@SECLEVEL=0')
                with socket.create_connection((self.host, self.port), timeout=5) as sock:
                    with ctx.wrap_socket(sock, server_hostname=self.host) as ssock:
                        req = f"GET / HTTP/1.1\r\nHost: {self.host}\r\nConnection: close\r\n\r\n".encode()
                        ssock.sendall(req)
                        data = b""
                        # Lire jusqu'√† fin des en-t√™tes
                        while b"\r\n\r\n" not in data:
                            chunk = ssock.recv(4096)
                            if not chunk:
                                break
                            data += chunk
                        header_blob = data.split(b"\r\n\r\n", 1)[0].decode(errors='ignore')
                        for line in header_blob.split("\r\n"):
                            if line.lower().startswith('x-dh-pub:'):
                                return line.split(':', 1)[1].strip()
                return None
            except Exception:
                return None

        ys_values: List[str] = []
        attempts = 6
        for idx in range(attempts):
            y_hex = fetch_dh_pub_header()
            if y_hex:
                ys_values.append(y_hex)
                print(f"   X-DH-Pub[{idx}]: {y_hex[:32]}... ({len(y_hex)} hex chars)")
                continue
            # 2) Fallback: extraction via openssl s_client -msg
            ske = self._run_openssl_capture_ske()
            if ske is None:
                print(f"   ‚ö†Ô∏è  Impossible de capturer ServerKeyExchange √† l'essai {idx+1}")
                continue
            ys = self._extract_dh_pub_from_ske(ske)
            if ys is None:
                continue
            ys_hex = ys.hex()
            ys_values.append(ys_hex)
            print(f"   Y_s[{idx}]: {ys_hex[:32]}... ({len(ys)} octets)")

        if len(ys_values) < 2:
            return {
                "reused": False,
                "details": "Pas assez d'observations de Y_s (ou X-DH-Pub) pour l'analyse",
                "keys": ys_values
            }

        unique = set(ys_values)
        print(f"   Valeurs Y_s/X-DH-Pub uniques: {len(unique)}/{len(ys_values)}")
        if len(unique) == 1:
            return {
                "reused": True,
                "details": "M√™me cl√© DH publique observ√©e sur toutes les connexions",
                "keys": ys_values
            }
        else:
            return {
                "reused": False,
                "details": "Cl√©s DH √©ph√©m√®res (valeur varie entre connexions)",
                "keys": ys_values
            }

    
    def _is_dhe_cipher(self, cipher_name: str) -> bool:
        """V√©rifie si le cipher utilise DHE"""
        dhe_indicators = ["DHE", "EDH"]
        return any(indicator in cipher_name.upper() for indicator in dhe_indicators)
    
    def _is_rsa_cipher(self, cipher_name: str) -> bool:
        """V√©rifie si le cipher utilise RSA pour l'√©change de cl√©s"""
        # RSA pur (pas DHE-RSA ou ECDHE-RSA)
        return ("RSA" in cipher_name.upper() or "AES" in cipher_name.upper()) and "DHE" not in cipher_name.upper() and "ECDHE" not in cipher_name.upper()
    
    def _is_ecdhe_cipher(self, cipher_name: str) -> bool:
        """V√©rifie si le cipher utilise ECDHE"""
        return "ECDHE" in cipher_name.upper()
    
    
    def print_results(self, results: Dict):
        """Affiche les r√©sultats de l'analyse"""
        print(f"\n" + "=" * 60)
        print(f"üìä R√âSULTATS DE L'ANALYSE RACCOON")
        print(f"=" * 60)
        
        status = results["status"]
        print(f"\nüè∑Ô∏è  STATUT: {status.value}")
        print(f"üìù RAISON: {results['reason']}")
        
        if "tls_info" in results:
            tls_info = results["tls_info"]
            print(f"\nüîê D√âTAILS TECHNIQUES:")
            print(f"   Version TLS: {tls_info.get('version', 'N/A')}")
            print(f"   Cipher: {tls_info.get('cipher_name', 'N/A')}")
            print(f"   Bits de s√©curit√©: {tls_info.get('secret_bits', 'N/A')}")
        
    
        
        print(f"\n" + "=" * 60)


def main():
    if len(sys.argv) != 3:
        print("Usage: python3 check_raccoon_vulnerability.py <host> <port>")
        print("Exemple: python3 check_raccoon_vulnerability.py localhost 8443")
        sys.exit(1)
    
    host = sys.argv[1]
    try:
        port = int(sys.argv[2])
    except ValueError:
        print("‚ùå Erreur: Le port doit √™tre un nombre")
        sys.exit(1)
    
    checker = RaccoonChecker(host, port)
    results = checker.check_vulnerability()
    checker.print_results(results)
    
    # Code de sortie bas√© sur le statut
    if results["status"] == VulnerabilityLevel.VULNERABLE:
        sys.exit(2)  # Vuln√©rable
    elif results["status"] == VulnerabilityLevel.UNKNOWN:
        sys.exit(3)  # Inconnu
    else:
        sys.exit(0)  # Prot√©g√© ou non vuln√©rable


if __name__ == "__main__":
    main()