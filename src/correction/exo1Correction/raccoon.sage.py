

# This file was *autogenerated* from the file raccoon.sage
from sage.all_cmdline import *   # import sage library

_sage_const_100 = Integer(100); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_12 = Integer(12); _sage_const_60 = Integer(60); _sage_const_10 = Integer(10); _sage_const_128 = Integer(128); _sage_const_1p75 = RealNumber('1.75'); _sage_const_8 = Integer(8); _sage_const_180 = Integer(180)
from fpylll import *
import os

outputs = os.path.abspath("output")

RR = RealField(_sage_const_100 )

os.environ["SAGE_NUM_THREADS"] = "48"

load("lib/Dh.sage")

@parallel()
def HnpSolver(label, dh, b, t, beta, fudge):
  start = walltime()
  def info(msg):
    elapsed = walltime() - start
    with open(os.path.join(outputs, label + ".out"), "a") as fh:
      fh.write("%s:%010.3f: %s\n" % (label, elapsed, msg))

  p = Integer(dh.p)
  q = Integer(dh.q)
  g = Integer(dh.g)
  nbits = dh.n

  eps = nbits - RR(log(p, _sage_const_2 )) # bias of the modulus
  ell = b - eps # effective number of given most significant bits

  # generate DH-keys
  sk_a = ZZ.random_element(_sage_const_1 , q)
  pk_a = power_mod(g, sk_a, p)
  sk_b = ZZ.random_element(_sage_const_1 , q)
  pk_b = power_mod(g, sk_b, p)

  # shared secret
  dh_ab = power_mod(pk_a, sk_b, p)
  assert( dh_ab == power_mod(pk_b, sk_a, p) )

  # generate HNP data (cheating, fast)
  mult = vector(ZZ, t)
  appr = vector(ZZ, t)
  dh_ab_inv = inverse_mod(dh_ab, p)
  for i in range(t):
    mult[i] = ( dh_ab_inv*ZZ.random_element(_sage_const_1 , _sage_const_2 **(nbits-b)) ).mod(p)
    appr[i] = _sage_const_2 **(nbits-b-_sage_const_1 )    
    dist = (mult[i]*dh_ab - appr[i]).mod(p)
    assert( min(dist, p-dist ) <= p/_sage_const_2 **(ell+_sage_const_1 ) )

  #build lattice
  B = matrix(ZZ, t+_sage_const_2 , t+_sage_const_2 )
  factor = ceil(_sage_const_2 **ell)
  B[_sage_const_0 , _sage_const_0 ] = _sage_const_1 
  B[_sage_const_1 , _sage_const_1 ] = ceil( p/(_sage_const_2 *fudge) )
  for i in range(t):
    B[  _sage_const_0 , i+_sage_const_2 ] = factor * mult[i]
    B[  _sage_const_1 , i+_sage_const_2 ] = factor * appr[i]
    B[i+_sage_const_2 , i+_sage_const_2 ] = factor * p

  # lattice invariants and heuristics
  def det_lattice(p, ell, t):
    return RR( ceil(p/(_sage_const_2 *sqrt(_sage_const_3 ))) * (ceil(_sage_const_2 **ell)*p)**t )
  def root_det_lattice(p, ell, t):
    return det_lattice(p, ell, t)**(_sage_const_1 /(t+_sage_const_2 ))
  def Gauss_heuristic(p, ell, t):
    return RR( sqrt((t+_sage_const_2 )/(_sage_const_2 *pi*e)) * det_lattice(p, ell, t)**(_sage_const_1 /(t+_sage_const_2 )) )
  def exp_norm_hidden_vector(p, t):
    return RR( sqrt((t+_sage_const_2 )/_sage_const_12 ) * p )
  def exp_Hermite_delta(p, ell, t):
    return exp_norm_hidden_vector(p, t) / root_det_lattice(p, ell, t)
  def exp_root_Hermite_delta(p, ell, t):
    return exp_Hermite_delta(p, ell, t)**(_sage_const_1 /(t+_sage_const_2 ))
  def gap_lattice(p, ell, t):
    return Gauss_heuristic(p, ell, t) / exp_norm_hidden_vector(p, t)
  def tau_lattice(p, ell, t):
    return gap_lattice(p, ell, t) / exp_Hermite_delta(p, ell, t)
    

  # modified lattice invariants and heuristics (shortest vector (p, 0, ..., 0) removed)
  def mod_det_lattice(p, ell, t):
    return det_lattice(p, ell, t) / p
  def mod_root_det_lattice(p, ell, t):
    return mod_det_lattice(p, ell, t)**(_sage_const_1 /(t+_sage_const_1 ))
  def mod_Gauss_heuristic(p, ell, t):
    return RR( sqrt((t+_sage_const_1 )/(_sage_const_2 *pi*e)) * mod_det_lattice(p, ell, t)**(_sage_const_1 /(t+_sage_const_1 )) )
  def mod_exp_norm_hidden_vector(p, t):
    return RR( sqrt((t+_sage_const_1 )/_sage_const_12 ) * p )
  def mod_exp_Hermite_delta(p, ell, t):
    return mod_exp_norm_hidden_vector(p, t) / mod_root_det_lattice(p, ell, t)
  def mod_exp_root_Hermite_delta(p, ell, t):
    return mod_exp_Hermite_delta(p, ell, t)**(_sage_const_1 /(t+_sage_const_1 ))
  def mod_gap_lattice(p, ell, t):
    return mod_Gauss_heuristic(p, ell, t) / mod_exp_norm_hidden_vector(p, t)
  def mod_tau_lattice(p, ell, t):
    return mod_gap_lattice(p, ell, t) / mod_exp_Hermite_delta(p, ell, t)

  det_B = det_lattice(p, ell, t)
  root_det_B = root_det_lattice(p, ell, t)
  gh_B = Gauss_heuristic(p, ell, t)
  exp_norm_hidden_vec = exp_norm_hidden_vector(p, t)
  exp_root_Hermite_del = exp_root_Hermite_delta(p, ell, t)

  mod_det_B = mod_det_lattice(p, ell, t)
  mod_root_det_B = mod_root_det_lattice(p, ell, t)
  mod_gh_B = mod_Gauss_heuristic(p, ell, t)
  mod_exp_norm_hidden_vec = mod_exp_norm_hidden_vector(p, t)
  mod_exp_root_Hermite_del = mod_exp_root_Hermite_delta(p, ell, t)

  info("Instance".center(_sage_const_60 , "="))
  info("# of equations: %i" % t)
  info("Gap: %.2f" % gap_lattice(p, ell, t))
  info("Tau: %.2f" % tau_lattice(p, ell, t))

  #solve HNP

  def root_Hermite_delta_BKZ(beta):
    return RR( (pi*beta)**(_sage_const_1 /beta)*beta/(_sage_const_2 *pi*e) )**(_sage_const_1 /(_sage_const_2 *(beta-_sage_const_1 )))
  exp_norm_BKZ = RR( root_Hermite_delta_BKZ(beta)**(t+_sage_const_2 ) * root_det_B )

  info(("BKZ-"+str(min(beta, t+_sage_const_2 ))+" reduction").center(_sage_const_60 , "="))
  time_total = walltime()
  C = IntegerMatrix.from_matrix(B)

  info("Expectedly achievable log(norm): %.2f" % log(exp_norm_BKZ, _sage_const_2 ))

  #basis vector norms
  mat = matrix(ZZ, C.nrows, C.ncols)
  C.to_matrix(mat)   
  norms = [round(log(sqrt(RR(row*row)), _sage_const_2 ), _sage_const_2 ) for row in mat]
  info("log(exp-norms): %r" % ([round(log(RR(p), _sage_const_2 ), _sage_const_2 ),
                          round(log(exp_norm_hidden_vec, _sage_const_2 ), _sage_const_2 ),
                          round(log(gh_B, _sage_const_2 ), _sage_const_2 )],))
  info("log(norms):     %r" % (norms[_sage_const_0 :_sage_const_10 ],))


  BKZ_params = BKZ.Param(block_size=beta,
                       strategies=load_strategies_json(BKZ.DEFAULT_STRATEGY),
                       max_loops=_sage_const_1 ,
                       #flags=BKZ.VERBOSE
                       )

  num_loops = _sage_const_100 
  for loop in range(num_loops):

    info("Loop %i/%i" % (loop+_sage_const_1 , num_loops))
    time_loop = walltime()
    BKZ.reduction(C, BKZ_params, float_type="mpfr", precision=_sage_const_128 )  
    C.to_matrix(B)      
    
    #basis vector norms
    mat = matrix(ZZ, C.nrows, C.ncols)
    C.to_matrix(mat)
    #root_Hermite_del = (sqrt(RR(mat[1]*mat[1]))/ root_det_B) ^ (1/(t+2))
    #info("(", root_Hermite_del, "/", exp_root_Hermite_del, ")")    
    norms = [round(log(sqrt(RR(row*row)), _sage_const_2 ), _sage_const_2 ) for row in mat]
    info("log(exp-norms): %r" % ([round(log(RR(p), _sage_const_2 ), _sage_const_2 ),
                              round(log(exp_norm_hidden_vec, _sage_const_2 ), _sage_const_2 ),
                              round(log(gh_B, _sage_const_2 ), _sage_const_2 )],))
    info("log(norms):     %r" % (norms[_sage_const_0 :_sage_const_10 ],))
            
    #done?
    solution = _sage_const_0 
    for row_vec in C:
        tmp = row_vec[_sage_const_0 ].mod(p)
        if tmp == dh_ab:
            solution = tmp
        if p-tmp == dh_ab:
            solution = p-tmp
    info("("+str(ceil(walltime(time_loop)))+" sec)")
    
    if solution:
        break
    

  #output
  info("Summary".center(_sage_const_60 , "="))
  elapsed = ceil(walltime(time_total))
  info("Total time: %isec" % ceil(walltime(time_total)))
  if solution:
    info("SUCCESS")
    info("HNP solution: %s" % (str(solution),))
    info("Shared secret: %s" % (str(dh_ab),))
    result = True
  else:
    info("FAIL")
    result = False

  summary = (nbits, b, t, beta, elapsed, result)
  info("SUMMARY:n:%i:k:%i:d:%i:bs:%i:t:%i:r:%r" % summary)
  if solution:
    return True
  else:
    return False

##########################
# Jobs are defined here! #
##########################

dh20 = Dh(name="20-bit prime")
dh50 = Dh(name="50-bit prime")
dh100 = Dh(name="100-bit prime")

fudges = [_sage_const_1 , _sage_const_1p75 , RR(sqrt(_sage_const_3 ))]

experiments = [
  (dh20, _sage_const_8 , _sage_const_180 , _sage_const_60 , fudges[_sage_const_0 ]),
  (dh50, _sage_const_8 , _sage_const_180 , _sage_const_60 , fudges[_sage_const_0 ]),
  (dh100, _sage_const_8 , _sage_const_180 , _sage_const_60 , fudges[_sage_const_0 ])
]

reps = _sage_const_1 

def generate_jobs():
  jobs = []
  cnt = _sage_const_0 
  for ex in experiments:
    for rep in range(reps):
      dh, k, d, bs, f = ex
      cnt = cnt + _sage_const_1 
      label = "exp%03i-n%i-k%02i-d%03i-bs%02i-f%.3f-r%02i" % (cnt, dh.n, k, d, bs, f, rep)
      jobs.append((label, dh, k, d, bs, f))
  return jobs
jobs = generate_jobs()

# Execute all.

begin = walltime()
for job in jobs:
    print("%s:%010.3f:BEGIN" % (job[_sage_const_0 ], _sage_const_0 ))

results = HnpSolver(jobs)

for res in results:
    pjob, ret = res
    job, obj = pjob
    elapsed = walltime() - begin
    print("%s:%010.3f:END:%r" % (job[_sage_const_0 ], elapsed, ret))

